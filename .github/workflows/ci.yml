name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
  DOTNET_NOLOGO: true
  NuGetDirectory: ${{ github.workspace}}/nuget

defaults:
  run:
    shell: pwsh

jobs:
  build-and-test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    
    steps:
    - name: ğŸ›’ Checkout
      uses: actions/checkout@v5
      with:
        fetch-depth: 0
    
    - name: âš™ï¸ Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: |
          6.0.x
          8.0.x
    
    - name: ğŸ“¦ Restore dependencies
      run: dotnet restore
    
    - name: ğŸ”¨ Build
      run: dotnet build --no-restore --configuration Release
    
    - name: ğŸ§ª Run tests
      run: dotnet test --no-build --configuration Release --verbosity normal --collect:"XPlat Code Coverage" --results-directory ./coverage
    
    - name: ğŸ“Š Upload coverage to Codecov
      if: matrix.os == 'ubuntu-latest'
      uses: codecov/codecov-action@v5
      with:
        directory: ./coverage
        fail_ci_if_error: false
        verbose: true

  package:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: ğŸ›’ Checkout
      uses: actions/checkout@v5
      with:
        fetch-depth: 0
    
    - name: âš™ï¸ Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: '8.0.x'
    
    - name: ğŸ“¦ Restore dependencies
      run: dotnet restore
    
    - name: ğŸ”¨ Build
      run: dotnet build --no-restore --configuration Release
    
    - name: ğŸ§ª Test
      run: dotnet test --no-build --configuration Release
    
    - name: ğŸ“¦ Create NuGet packages
      run: dotnet pack --configuration Release --no-build --output ${{ env.NuGetDirectory }}
    
    - name: ğŸ“¤ Upload NuGet package artifacts
      uses: actions/upload-artifact@v4
      with:
        name: nuget-packages
        if-no-files-found: error
        retention-days: 7
        path: ${{ env.NuGetDirectory }}/*.nupkg

  validate-nuget:
    needs: package
    runs-on: ubuntu-latest
    
    steps:
    - name: âš™ï¸ Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: '8.0.x'
    
    - name: ğŸ“¥ Download NuGet package artifacts
      uses: actions/download-artifact@v5
      with:
        name: nuget-packages
        path: ${{ env.NuGetDirectory }}
    
    - name: ğŸ” Validate NuGet packages
      run: |
        echo "Validating NuGet packages..."
        foreach($file in (Get-ChildItem "${{ env.NuGetDirectory }}" -Recurse -Include *.nupkg)) {
          Write-Host "Validating package: $($file.Name)"
          
          # Check if package exists and has reasonable size
          if ($file.Length -lt 1KB) {
            Write-Error "Package $($file.Name) is too small (less than 1KB)"
            exit 1
          }
          
          Write-Host "âœ… Package size check passed: $($file.Length) bytes"
          
          # Try advanced validation, fall back to basic if needed
          $validationPassed = $false
          
          try {
            # Advanced validation: Extract and inspect package contents
            $tempDir = Join-Path ([System.IO.Path]::GetTempPath()) ([System.Guid]::NewGuid().ToString())
            New-Item -ItemType Directory -Path $tempDir -Force | Out-Null
            
            # Verify temp directory exists
            if (-not (Test-Path $tempDir)) {
              throw "Failed to create temp directory"
            }
            
            # Load compression assembly and extract
            Add-Type -AssemblyName System.IO.Compression.FileSystem
            [System.IO.Compression.ZipFile]::ExtractToDirectory($file.FullName, $tempDir)
            
            # Check for .nuspec file
            $nuspecFiles = Get-ChildItem $tempDir -Filter "*.nuspec" -Recurse
            if ($nuspecFiles.Count -eq 0) {
              throw "Missing .nuspec file"
            }
            
            Write-Host "âœ… Advanced validation passed: Package structure is valid"
            $validationPassed = $true
            
            # Clean up
            Remove-Item $tempDir -Recurse -Force -ErrorAction SilentlyContinue
          }
          catch {
            Write-Host "âš ï¸ Advanced validation failed: $($_.Exception.Message)"
            Write-Host "ğŸ”„ Falling back to basic validation..."
            
            # Clean up on error
            if (Test-Path $tempDir -ErrorAction SilentlyContinue) {
              Remove-Item $tempDir -Recurse -Force -ErrorAction SilentlyContinue
            }
            
            # Basic validation: Check if file is a valid ZIP
            try {
              Add-Type -AssemblyName System.IO.Compression.FileSystem
              $zipFile = [System.IO.Compression.ZipFile]::OpenRead($file.FullName)
              $entryCount = $zipFile.Entries.Count
              $zipFile.Dispose()
              
              if ($entryCount -gt 0) {
                Write-Host "âœ… Basic validation passed: Package contains $entryCount entries"
                $validationPassed = $true
              } else {
                throw "Package appears to be empty"
              }
            }
            catch {
              Write-Error "âŒ Basic validation also failed: $($_.Exception.Message)"
              exit 1
            }
          }
          
          if (-not $validationPassed) {
            Write-Error "âŒ Package validation failed for $($file.Name)"
            exit 1
          }
        }
        Write-Host "ğŸ‰ All packages validated successfully!"

  security-scan:
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write
    
    steps:
    - name: ğŸ›’ Checkout
      uses: actions/checkout@v5
    
    - name: ğŸ”’ Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: csharp
    
    - name: âš™ï¸ Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: '8.0.x'
    
    - name: ğŸ”¨ Build for analysis
      run: |
        dotnet restore
        dotnet build --configuration Release
    
    - name: ğŸ” Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3
      with:
        category: "/language:csharp"

  deploy:
    needs: [build-and-test, package, validate-nuget]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    permissions:
      contents: write  # Required to create releases and tags
    
    steps:
    - name: ğŸ›’ Checkout code
      uses: actions/checkout@v5
      with:
        fetch-depth: 0  # Fetch full history for changelog generation
    
    - name: âš™ï¸ Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: '8.0.x'
    
    - name: ğŸ“¥ Download NuGet package artifacts
      uses: actions/download-artifact@v5
      with:
        name: nuget-packages
        path: ${{ env.NuGetDirectory }}
    
    - name: ğŸ“‹ Get current version from project file
      id: get_version
      run: |
        $projectFile = "MDLSoft.StringParsers/MDLSoft.StringParsers.csproj"
        $content = Get-Content $projectFile -Raw
        
        if ($content -match '<Version>([^<]+)</Version>') {
          $version = $matches[1]
          $tag = "v$version"
          
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          echo "TAG=$tag" >> $env:GITHUB_OUTPUT
          
          Write-Host "Current version: $version"
          Write-Host "Tag to create: $tag"
        } else {
          Write-Error "Could not extract version from project file"
          exit 1
        }
    
    - name: ğŸ·ï¸ Check if tag already exists
      id: check_tag
      run: |
        $tag = "${{ steps.get_version.outputs.TAG }}"
        
        # Fetch all tags
        git fetch --tags
        
        # Check if tag exists
        $tagExists = git tag -l $tag
        
        if ($tagExists) {
          echo "TAG_EXISTS=true" >> $env:GITHUB_OUTPUT
          Write-Host "Tag $tag already exists, skipping release creation"
        } else {
          echo "TAG_EXISTS=false" >> $env:GITHUB_OUTPUT
          Write-Host "Tag $tag does not exist, will create release"
        }
    
    - name: ğŸ“ Generate release notes
      id: release_notes
      if: steps.check_tag.outputs.TAG_EXISTS == 'false'
      run: |
        $tag = "${{ steps.get_version.outputs.TAG }}"
        
        # Get previous tag for comparison
        $allTags = git tag --sort=-version:refname
        $previousTag = $allTags | Where-Object { $_ -ne $tag } | Select-Object -First 1
        
        if ($previousTag) {
          Write-Host "Previous tag: $previousTag"
          
          # Get commits since previous tag
          $commitDetails = git log --pretty=format:"%H|%s|%an" "$previousTag..HEAD"
          
          # Build release notes
          $releaseNotes = @"
## What's Changed
"@
          
          # Add commit links
          foreach ($commitLine in ($commitDetails -split "`n")) {
            if ($commitLine -and $commitLine.Contains('|')) {
              $parts = $commitLine -split '\|', 3
              $fullHash = $parts[0]
              $message = $parts[1]
              $author = $parts[2]
              
              $releaseNotes += "`n* $message by @$author in https://github.com/${{ github.repository }}/commit/$fullHash"
            }
          }
          
          # Categorize changes
          $fixes = @()
          $features = @()
          $chores = @()
          $improvements = @()
          
          $commits = git log --oneline "$previousTag..HEAD"
          foreach ($commit in ($commits -split "`n")) {
            if ($commit -match "^[a-f0-9]+\s+(.+)$") {
              $message = $matches[1]
              if ($message -match "^fix[:(\[]") { $fixes += "- $message" }
              elseif ($message -match "^feat[:(\[]") { $features += "- $message" }
              elseif ($message -match "^chore[:(\[]") { $chores += "- $message" }
              else { $improvements += "- $message" }
            }
          }
          
          # Add categorized sections
          if ($features.Count -gt 0) {
            $releaseNotes += "`n`n## ğŸš€ New Features`n" + ($features -join "`n")
          }
          
          if ($fixes.Count -gt 0) {
            $releaseNotes += "`n`n## ğŸ”§ Bug Fixes`n" + ($fixes -join "`n")
          }
          
          if ($improvements.Count -gt 0) {
            $releaseNotes += "`n`n## âœ¨ Improvements`n" + ($improvements -join "`n")
          }
          
          if ($chores.Count -gt 0) {
            $releaseNotes += "`n`n## ğŸ§¹ Maintenance`n" + ($chores -join "`n")
          }
          
          $releaseNotes += "`n`n**Full Changelog**: https://github.com/${{ github.repository }}/compare/$previousTag...$tag"
        } else {
          $releaseNotes = @"
## ğŸ‰ Release $tag

This release includes the latest updates and improvements to MDLSoft.StringParsers.

**Full Changelog**: https://github.com/${{ github.repository }}/commits/$tag
"@
        }
        
        # Save release notes to output
        $releaseNotesFile = "release-notes.md"
        $releaseNotes | Out-File -FilePath $releaseNotesFile -Encoding UTF8
        
        # Set output for next step
        echo "RELEASE_NOTES_FILE=$releaseNotesFile" >> $env:GITHUB_OUTPUT
        Write-Host "Release notes generated successfully"
    
    - name: ğŸš€ Create GitHub Release and Tag
      if: steps.check_tag.outputs.TAG_EXISTS == 'false'
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.get_version.outputs.TAG }}
        name: ${{ steps.get_version.outputs.TAG }}
        body_path: release-notes.md
        draft: false
        prerelease: false
        files: ${{ env.NuGetDirectory }}/*.nupkg
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: ğŸ“¦ Publish NuGet packages
      run: |
        foreach($file in (Get-ChildItem "${{ env.NuGetDirectory }}" -Recurse -Include *.nupkg)) {
          Write-Host "Publishing package: $($file.Name)"
          dotnet nuget push $file --api-key "${{ secrets.NUGET_API_KEY }}" --source https://api.nuget.org/v3/index.json --skip-duplicate
        }